{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"customprovisionlicense/","title":"Custom Provision License","text":""},{"location":"customprovisionlicense/#copyright-c-2024-fancy-ducc","title":"Copyright (c) 2024 Fancy Ducc","text":"<p><pre><code>Permission is hereby granted, free of charge, to any person obtaining a copy of this software \nand associated documentation files (the \"Software\"), to deal in the Software with the \nfollowing conditions:\n\nThe Software may not be sold for profit on its own or as a standalone product, under \nany circumstance. The Software may be modified, distributed, used privately, and \nused commercially within a project, provided that proper credit is given to the \noriginal creator of the Software. No revenue generated from the project is owed to \nthe  original creator of the Software, and all revenue generated from the project \nremains the property of the project's owner.\n\nThe Software may not be used, distributed, modified, or downloaded illegaly and without\nproper permission.\n\nThe Software is provided \"as is,\" without warranty of any kind, express or implied, \nincluding but not limited to the warranties of merchantability, fitness for a particular \npurpose, and noninfringement. In no event shall the authors or copyright holders be liable \nfor any claim, damages, or other liability, whether in an action of contract, tort, or \notherwise, arising from, out of, or in connection with the Software or the use or other \ndealings in the Software.\n\nNo permission is granted to use the trade names, trademarks, service marks, or product \nnames of the copyright holder, except as required for reasonable and customary use in \ndescribing the origin of the Software. This license does not grant permission to use or \npractice any patents that may be necessary to utilize the Software.\n</code></pre> By downloading this software, you are agreeing to these terms and acknowledging that this license has/was applied to you.</p>"},{"location":"getting-started/","title":"VortexFX Documentation","text":"<p>Current Version: 1.0.6 - Groups</p> <p></p>"},{"location":"getting-started/#introduction","title":"Introduction","text":"<p>Welcome to the official VortexFX documentation!</p> <p>This system is designed to be able to give you just a bit more control over particles, and make them 3D at the same time! This system has features that go beyond normal 2D particles, the goal behind this system is to give you the freedom to create just about anything you can imagine.</p> <p>If you\u2019re aiming for effects like fireflies or lightning bolts or audio visualization, this system has you covered.</p> <p>Notice</p> <p>VortexFX is in no way whatsoever meant to replace 2D particles, 2D particles are much more performance friendly and look better for circumstances that need it, 3D Particles are meant to add onto 2D particles or to be used as extra decoration.</p> <p>Videos are provided for almost all properties so you can determine the properties you need to get a perfect result before needing to download anything Videos are NOT provided for super simple properties, like Rate or LifeTime</p>"},{"location":"getting-started/#key-features","title":"Key Features","text":"<p>Here\u2019s a quick rundown of what makes this particle system special:</p>"},{"location":"getting-started/#realtime-collision-detection","title":"Realtime Collision Detection","text":"<p>This isn\u2019t just for looks. Each particle can collide with the environment and respond in cool ways. Which can be useful for bouncy balls that bounce off walls or particles that react when they hit the ground.</p>"},{"location":"getting-started/#trajectory-vertices","title":"Trajectory Vertices","text":"<p>With this, you can make particles follow a path you define. If you need any shape from a straight line, to a circle, all the way to a rhombicosidodecahedron. This makes it super easy to control where your particles go without fully worrying about adjusting where your particles go with properties only.</p>"},{"location":"getting-started/#3d-light-influence","title":"3D Light Influence","text":"<p>Lighting can make or break an effect, and with this system, your particles can be influenced by the lights. Such as glowing embers that dim as they move away from a light source. These little touches can make a big difference in how your game feels.</p> <p>Light influence is still in development</p> <p>You may or may not come across flickers, bad shadow casting, or more, there are plenty of possible bugs that can happen with light influence, most of the bugs only happen with Shadows, so if you don't mind losing a bit of detail, maybe turn off those extra shadows that won't cause a problem.</p>"},{"location":"getting-started/#instability","title":"Instability","text":"<p>Instability allows particles to adjust their position slightly from where they originally are, this feature paired with trails is exceptional for lightning or electricity effects.</p> <p>If you ever feel stuck or just want to explore what\u2019s possible with the system, this documentation is here to help, everything you need to know should be in this documentation, if not; please message me on Discord at distinguished_duccer.</p>"},{"location":"installation/","title":"Installation","text":"<p>Getting started with VortexFX is very easy and straightforward, so you can focus more on creation than the boring stuff. Just follow these quick steps, and you\u2019ll be up and running in no time.</p>"},{"location":"installation/#step-1-download-the-module","title":"Step 1: Download the Module","text":"<p>First, you\u2019ll need to download the <code>.rbxm</code> file that contains the VortexFXParticles module.</p> <p>Download the VortexFXParticles Module</p> <p>If you aren't comfortable with downloading the file or you are having troubles downloading it, a different method is to install from the Roblox creator hub, you can install the model from here: </p> <p>Roblox Creator Hub</p>"},{"location":"installation/#step-2-insert-the-module-into-your-project","title":"Step 2: Insert the Module into Your Project","text":"<p>Once you\u2019ve downloaded the module, open up your Roblox Studio experience. You can place the module in either ReplicatedStorage or ServerScriptService, depending on your experience needs. Here\u2019s how to do it:</p> <ol> <li> <p>Drag and Drop: Simply drag the downloaded <code>.rbxm</code> file from your file explorer into the Viewport panel (The area where you can see the game world) in Roblox Studio.</p> </li> <li> <p>Click and use: If you instead installed through the Roblox Creator Hub, you'll find the module in the Toolbox &gt; My Models &gt; VortexFXParticles, simply drag and drop or click on the panel and the module will add to the game.</p> </li> <li> <p>Placement: Place the module in ReplicatedStorage if you want it to be accessible to both server and client scripts. If it's only going to be used server-side, ServerScriptService is the best spot for it.</p> </li> </ol> <p>Note</p> <p>The module is strongly recommended to be placed in the ReplicatedStorage and for most particles to be used on the Client, it's not recommended to use particles on the server as it can cause lag to every player when many particles are in use.</p>"},{"location":"installation/#step-3-require-the-module","title":"Step 3: Require the Module","text":"<p>With the module in place, it\u2019s time to require it in your scripts. Here\u2019s a quick example of how to do this:</p> <p><pre><code>    local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n    local VortexFXParticles = require(ReplicatedStorage:WaitForChild(\"VortexFXParticles\"))\n</code></pre> Or if you chose to place the module inside of the ServerScriptService then you'll want to use: <pre><code>    local ServerScriptService = game:GetService(\"ServerScriptService\")\n    local VortexFXParticles = require(ServerScriptService:WaitForChild(\"VortexFXParticles\"))\n</code></pre></p>"},{"location":"modulechangelog/","title":"Update Log","text":"<p>Here you can see what updates the module has gone through, as well as a completely separate download for every update, incase you want to back-track or modify an older version.</p> <p>There will not be a Creator Hub link for every older version however, as Roblox won't let me do that, so you'll need to download the <code>.rbxm</code> file for older versions.</p>"},{"location":"modulechangelog/#version-100-debut","title":"Version 1.0.0 - Debut","text":""},{"location":"modulechangelog/#downloads","title":"Downloads","text":"<ul> <li>V1.0.0 Module</li> </ul>"},{"location":"modulechangelog/#version-101-flipbooks","title":"Version 1.0.1 - Flipbooks","text":""},{"location":"modulechangelog/#changes","title":"Changes:","text":"<ul> <li>Added New Page Update Log</li> <li>Added Property Flipbook</li> <li>Added Prerequisite ObjectCache</li> <li>Removed Prerequisite PartCache</li> <li>Removed Prerequisite FastCastRedux</li> <li>Changed Name PartCacheFolder &gt; ParticleCache</li> </ul>"},{"location":"modulechangelog/#downloads_1","title":"Downloads","text":"<ul> <li>V1.0.1 Module</li> </ul>"},{"location":"modulechangelog/#version-102-stuff-i-forgot-to-do","title":"Version 1.0.2 - Stuff I forgot to do","text":""},{"location":"modulechangelog/#changes_1","title":"Changes:","text":"<ul> <li>Added New Page Particle Commands</li> <li>Added Function FreezeParticle</li> <li>Added Function UnfreezeParticle</li> <li>Added Function GetActiveParticlesCount</li> <li>Added Function ChangeParticleProperty</li> <li>Added Function DestroyParticle</li> <li>Added Function SetParticlePosition</li> <li>Added Function SetParticleOrientation</li> <li>Added Function ResetRotation</li> <li>Added Property VelocityInheritance</li> <li>Added Free Template Falling Leaves</li> <li>Added Feature Vector3 can now be used with Size</li> <li>Removed Property LockedToPart</li> <li>Removed Obsolete functions and code</li> <li>Changed Property Rotation</li> <li>Changed Property RotationSpeed</li> <li>Fixed False flipbook warning</li> <li>Fixed SpreadAngle Y axis not doing anything</li> </ul>"},{"location":"modulechangelog/#downloads_2","title":"Downloads","text":"<ul> <li>V1.0.2 Module</li> </ul>"},{"location":"modulechangelog/#version-103-gun","title":"Version 1.0.3 - Gun","text":""},{"location":"modulechangelog/#changes_2","title":"Changes:","text":"<ul> <li>Added Property CollisionRange</li> <li>Added Free Template Gun</li> <li>Changed Property SpreadAngle</li> </ul>"},{"location":"modulechangelog/#downloads_3","title":"Downloads","text":"<ul> <li>V1.0.3 Module</li> </ul>"},{"location":"modulechangelog/#version-104-models-n-more","title":"Version 1.0.4 - Models n' More","text":""},{"location":"modulechangelog/#changes_3","title":"Changes:","text":"<ul> <li>Added Property KeepOriginalTransparencies</li> <li>Added Property KeepOriginalColors</li> <li>Added Property KeepOriginalMaterials</li> <li>Added Property InstabilitySmoothness</li> <li>Changed Property Completely revamped Instability</li> <li>Changed Property SpreadAngle from Vector2 to Vector3</li> <li>Changed Free Template Revamped AudioOrbs</li> <li>Changed Free Template Revamped Fireworks</li> <li>Changed Free Template Revamped Fireflies</li> <li>Changed Free Template Revamped BouncyBalls</li> <li>Changed Free Template Revamped AudioWaveform</li> <li>Removed Free Template Falling Leaves</li> <li>Fixed SpreadAngle in templates broken</li> <li>Fixed Models not emitting correctly</li> </ul>"},{"location":"modulechangelog/#downloads_4","title":"Downloads","text":"<ul> <li>V1.0.4 Module</li> </ul>"},{"location":"modulechangelog/#version-105-pure-performance","title":"Version 1.0.5 - Pure Performance","text":""},{"location":"modulechangelog/#changes_4","title":"Changes:","text":"<ul> <li> <p>New Logo and Name VortexFX</p> </li> <li> <p>Added Property LookAt</p> </li> <li>Added Property EmissionShape</li> <li>Added Property CullingEnabled</li> <li>Added Property AggressiveCullingEnabled</li> <li>Added Property FocusAware</li> <li>Added Property RenderDistance</li> <li>Added Property MaximumParticleCount</li> <li>Added Property MinimumParticleCount</li> <li>Added Property AdaptiveParticleLimits</li> <li>Added Property CullingExtentsOffset</li> <li>Added New Page Performance Properties</li> <li>Changed Property Added CFrame options for Rotation</li> <li>Changed System Revamped Reactive Coordinate Interaction Point (RCIP)</li> <li>Added Free Template Lasers</li> </ul>"},{"location":"modulechangelog/#downloads_5","title":"Downloads","text":"<ul> <li>V1.0.5 Module</li> </ul>"},{"location":"modulechangelog/#version-106-groups","title":"Version 1.0.6 - Groups","text":""},{"location":"modulechangelog/#changes_5","title":"Changes:","text":"<ul> <li>Added Property Grouped</li> <li>Added Property GroupAmount</li> <li>Added Property ParticlesPerGroup</li> <li>Added Property GroupBehavior</li> <li>Added Property GroupRotationBehavior</li> <li>Added Property GroupBehaviorOnHeartDeath</li> <li>Added Property ScatterPower</li> <li>Added Property AvoidDistance</li> <li>Added Property ClusterDistance</li> <li>Added Property GroupWalkExtents</li> <li>Added Property GroupWalkAggression</li> <li>Added Property OneToOneOffset</li> <li>Added Property GroupKillDelay</li> <li>Added Property GroupOrbitRange</li> <li>Added Property GroupOrbitAxis</li> <li>Added Property GroupOrbitSpeed</li> <li>Added Property GroupOrbitSmoothing</li> <li>Added Property Attractor</li> <li>Added Property Repulsor</li> <li>Added Property AttractorRange</li> <li>Added Property AttractorIntensity</li> <li>Added Property AttractorStyle</li> <li>Added Property RepulsorRange</li> <li>Added Property RepulsorIntensity</li> <li>Added Property RepulsorStyle</li> <li>Added Property CollisionGroup</li> <li>Added Property VelocityInheritor</li> <li>Added New Page Group Properties</li> </ul>"},{"location":"modulechangelog/#downloads_6","title":"Downloads","text":"<ul> <li>V1.0.6 Module</li> </ul>"},{"location":"prerequisites/","title":"Prerequisites","text":"<p>The VortexFX System module is designed to work  with the ObjectCache module, which helps optimize the reuse of parts for better performance. The good news is you don\u2019t need to worry about setting it up separately, it comes preinstalled with the VortexFX System system.</p> <p>The ObjectCache module is already included with the VortexFX System module, so there's no need for additional downloads or installations. It\u2019s integrated and ready to use as soon as you set up the VortexFX System.</p>"},{"location":"prerequisites/#download-the-objectcache-module-optional","title":"Download the ObjectCache Module (Optional)","text":"<p>If you\u2019re interested in using ObjectCache separately for other projects or want to explore its functionality on its own, you can see it here:</p> <p>ObjectCache Module (Devforum)</p> <p>The VortexFX System module is designed to work use the CastVisuals module, which helps visualize raycasting with minimal performance hits. This as well as the ObjectCache module comes pre-installed with the latest version of VortexFX, you don't need to do anything special.</p> <p>The CastVisuals module is already included with the VortexFX System module, so there's no need for additional downloads or installations. It\u2019s integrated and ready to use as soon as you set up the VortexFX System.</p>"},{"location":"prerequisites/#download-the-castvisuals-module-optional","title":"Download the CastVisuals Module (Optional)","text":"<p>If you\u2019re interested in using CastVisuals separately for other projects or want to explore its functionality on its own, you can see it here:</p> <p>ObjectCache Module (Devforum)</p>"},{"location":"reportbugrequest/","title":"Report an Issue or Request a Feature","text":"<p>The form below lets you send a report, request, or whatever to the creator of the module himself, think about what you say because there is a 5 minute cooldown between report sends</p> Discord Username (@ExampleName) or method I can contact you back with: Issue/Request: Send"},{"location":"templatelist/","title":"Free Templates","text":"<p>To help you get started quickly, the system has a collection of pre-made templates that showcase the versatility of the VortexFX System. Each template is designed to be easily customizable, so you can change them to fit your needs.</p>"},{"location":"templatelist/#how-to-use","title":"How to Use","text":"<p>Each template is an <code>.rbxm</code> file. Simply download the file and drop it into the viewport in your Roblox experience. From there, you can use the template in your experience to do all sorts of things.</p> <p>Don't expect lots of these, most of these templates are made simply from me using the system.</p>"},{"location":"templatelist/#available-templates","title":"Available Templates","text":""},{"location":"templatelist/#bouncy-balls","title":"Bouncy Balls","text":"<p>Particle Count: <code>Low</code></p> <p>Download Bouncy Balls Template</p>"},{"location":"templatelist/#fireflies","title":"Fireflies","text":"<p>Particle Count: <code>Medium</code></p> <p>Download Fireflies Template</p>"},{"location":"templatelist/#lasers","title":"Lasers","text":"<p>Particle Count: <code>Medium</code></p> <p>Download Audio Orbs Template</p>"},{"location":"templatelist/#gun","title":"Gun","text":"<p>Particle Count: <code>Medium/High</code></p> <p>Download Gun Template</p>"},{"location":"templatelist/#audio-orbs","title":"Audio Orbs","text":"<p>Particle Count: <code>High</code></p> <p>Download Audio Orbs Template</p>"},{"location":"templatelist/#audio-waveform","title":"Audio Waveform","text":"<p>Particle Count: <code>High</code></p> <p>Download Audio Waveform Template</p> <p>Other features</p> <p>The Audio Waveform template has some other disabled features inside of the emitter and reference object</p> <p>The trail is disabled, enable it and make the waveform parts fully transparent inside the script for a smoother and objectively prettier result</p> <p>The emitter has a wave script that rocks the emitter back and fourth, creating a wave-like effect.</p>"},{"location":"templatelist/#fireworks","title":"Fireworks","text":"<p>Particle Count: <code>Very High</code></p> <p>Download Fireworks Template</p> <p>These templates are a great way to see what the VortexFX System can do. Download them, tweak them, make them your own, whatever you want or need.</p>"},{"location":"usage/","title":"Usage","text":"<p>Now that you have VortexFX installed, let's actually use it. This guide will show you how to set up the emitter and adjust some basic properties to get you started. </p>"},{"location":"usage/#setting-up-the-particle-emitter","title":"Setting Up the Particle Emitter","text":"<p>First things first, you'll need to create a new script or add to an existing one where you want to use VortexFX.</p> <p>Here\u2019s how to set up the emitter:</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal VortexFXParticles = require(ReplicatedStorage:WaitForChild(\"VortexFXParticles\"))\n\nlocal part = workspace:WaitForChild(\"Part\") -- Replace this line in your game where you want the particles to emit from, this can be either an attachment or a basepart\nlocal emitter = VortexFXParticles.new(part)\n\nemitter:Create({ -- Properties here\n\n})\n</code></pre> <p>In this example, we're requiring the VortexFXParticles module and creating a new emitter attached to a part in your workspace. Make sure to replace <code>\"Part\"</code> with the actual name of the part you want to attach the emitter to.</p>"},{"location":"usage/#adding-basic-properties","title":"Adding Basic Properties","text":"<p>Once your emitter is set up, you can start customizing it with many properties. Here are some basic ones to get you started:</p>"},{"location":"usage/#rate","title":"Rate","text":"<p>The <code>Rate</code> property determines how many particles are emitted per second.</p> <pre><code>emitter:Create({ -- Emit 10 particles per second\n    Rate = 10\n})\n</code></pre>"},{"location":"usage/#lifetime","title":"Lifetime","text":"<p>The <code>Lifetime</code> property controls how long each particle lives before disappearing. You can set this as a <code>NumberRange</code> to give particles a range of lifetimes, if you have a bit of scripting knowledge, then consider <code>NumberRange</code> how a <code>math.random()</code> works.</p> <pre><code>emitter:Create({ -- Particles live between 3 to 5 seconds\n    Lifetime = NumberRange.new(3, 5)\n})\n</code></pre>"},{"location":"usage/#color","title":"Color","text":"<p>The <code>Color</code> property allows you to set the color of the particles. You can use a <code>ColorSequence</code> to have particles change color over their lifetime.</p> <pre><code>emitter:Create({ -- Particles transition from red to yellow\n    Color = ColorSequence.new(Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 255, 0))\n})\n</code></pre> <p>For creating more extensive <code>ColorSequence</code>'s, you'll need to use <code>ColorSequenceKeypoint</code>, here is an example of how to do that: <pre><code>emitter:Create({\n    Color = ColorSequence.new({\n        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 235, 156)),\n        ColorSequenceKeypoint.new(0.25, Color3.fromRGB(110, 137, 255)),\n        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(46, 255, 203)),\n        ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 129, 131)),\n        ColorSequenceKeypoint.new(1, Color3.fromRGB(237, 255, 210)),\n    })\n})\n</code></pre></p>"},{"location":"usage/#combining-properties","title":"Combining Properties","text":"<p>You can combine these properties and more to fine-tune the behavior of your particles:</p> <p><pre><code>emitter:Create({\n    Rate = 15,\n    Lifetime = NumberRange.new(2, 4),\n    Color = ColorSequence.new(Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 0, 255)),\n    Size = NumberSequence.new(1, 2)\n})\n</code></pre> So with that, a full script should look something like:</p> Expand <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal VortexFXParticles = require(ReplicatedStorage:WaitForChild(\"VortexFXParticles\"))\n\nlocal part = workspace:WaitForChild(\"Part\")\nlocal emitter = VortexFXParticles.new(part)\n\nemitter:Create({\n    Rate = 15,\n    Lifetime = NumberRange.new(2, 4),\n    Color = ColorSequence.new(Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 0, 255)),\n    Size = NumberSequence.new(1, 2)\n})\n</code></pre> <p>Emitters begin enabled</p> <p>All emitters created begin enabled. You'll have to put <code>Enabled = false</code> in the <code>Create({</code> section or <code>emitter:Stop()</code> at the end of the section outside of the brackets if you want the emitter to start disabled.</p> <p>In this example, particles are emitted at a rate of 15 per second, live between 2 to 4 seconds, change color from green to blue, and grow in size over their lifetime.</p>"},{"location":"usage/#activating-and-stopping-the-emitter","title":"Activating and Stopping the Emitter","text":"<p>To start the particle emitter, use:</p> <pre><code>emitter:Start()\n</code></pre> <p><code>emitter.enabled = true</code> also works, however it is recommended to use <code>emitter:Start()</code> as it correctly sets <code>RunService</code> loops</p> <p>When you want to stop emitting particles, simply use:</p> <pre><code>emitter:Stop()\n</code></pre> <p><code>emitter.enabled = false</code> also works, however it is recommended to use <code>emitter:Stop()</code> as it correctly ends <code>RunService</code> loops</p> <p>When you want to destroy the emitter and remove all particles, use:</p> <pre><code>emitter:Kill()\n</code></pre> <p><code>emitter:Kill()</code> will only destroy particles and stop emitting them, you can use <code>emitter:Start()</code> to start the same emitter again.</p>"},{"location":"usage/#useful-things-to-know","title":"Useful things to know","text":"<p>All properties of emitters can be modified from any script when using <code>GetEmitterFromID</code> or anywhere in a script where the emitter is created, the only requirement is that the emitter has those properties used, for example; It is not possible to change the <code>SpreadAngle</code> of the emitters if <code>SpreadAngle</code> is not created in the <code>emitter:Create({</code> table.</p> <p>While <code>emitter.enabled</code> works for starting and stopping the emitter, it is not recommended, and while <code>Enabled</code> is a property in the <code>emitter:Create({</code> that works, it also isn't recommended to use, it's more recommended to use <code>emitter:Start()</code> or <code>emitter:Stop()</code> immediately outside of the <code>emitter:Create({</code> table if you want to start the emitter disabled.</p> <p>When using property functions and timing anything using a <code>task.wait()</code> it is more recommended to use <code>task.delay(time, function())</code> at least once in the property function, otherwise the function will halt all particle updates.</p> <p>And that's all for usage, this should give you a good starting point to experiment and create different effects. For more advanced properties and customizations, go to the properties section of the documentation.</p>"},{"location":"properties/advanced-properties/","title":"Advanced Properties","text":"<p>Oh? Basic properties aren't enough for you? Fine.</p> <p>The system has many other properties that you can use to have even more control and flexibility over particle effects. These properties let you fine-tune stuff and visual effects that go beyond the basics.</p>"},{"location":"properties/advanced-properties/#referenceobject","title":"ReferenceObject","text":"<ul> <li>Description: Specifies a part or model (yes you heard that right, model) that particles will reference during their lifetime. This is useful for creating effects that follow a specific object.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>local reference = workspace:WaitForChild(\"Part\") -- Replace with a part or model\nemitter:Create({ -- Particles will reference this object\n    ReferenceObject = reference\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#windaffectsdrag","title":"WindAffectsDrag","text":"<ul> <li>Description: Allows wind to effect how particles move around in the world.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles are affected by wind forces\n    WindAffectsDrag = true\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#emissionshape","title":"EmissionShape","text":"<ul> <li>Description: Changes what shape particles can emit from the adornee</li> <li>Default: <code>Enum.ParticleEmitterShape.Box</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will emit in a cylinder pattern\n    EmissionShape = Enum.ParticleEmitterShape.Cylinder\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#facevelocity","title":"FaceVelocity","text":"<ul> <li>Description: Makes particles face the direction they are moving.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will face the direction of their movement\n    FaceVelocity = true\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#particlefolder","title":"ParticleFolder","text":"<ul> <li>Description: Determines the folder where particles are stored in the game hierarchy.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will be organized under this folder\n    ParticleFolder = game.Workspace(\"Particles\")\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#randomizedcolor","title":"RandomizedColor","text":"<ul> <li>Description: When enabled, assigns a random color to each particle.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will have random colors\n    RandomizedColor = true\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#castshadow","title":"CastShadow","text":"<ul> <li>Description: Determines whether the particles cast shadows.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will cast shadows\n    CastShadow = true\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#emitterid","title":"EmitterID","text":"<ul> <li>Description: When specified, any string (a word inside of \"quotes\") will turn into an ID that is binded to the emitter, which allows you to run any function from any emitter from any script, as long as the script that remotely interacts with the script is the same <code>RunContext</code> as the script that created the emitter, so Client scripts can only remotely control other client emitters, while server scripts can only remotely control other server emitters, they cannot cross. ID can be literally anything as long as it is a string.</li> <li>Default: <code>\"Default\"</code></li> <li>Example: <pre><code>emitter:Create({ -- Emitter will be paired with \"EmitterID1\"\n    EmitterID = \"EmitterID1\"\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#getemitterbyid","title":"GetEmitterByID","text":"<ul> <li>Description: When called, the variable paired with the function recieves a callback of the emitter, allowing you to run any function from any emitter from any script, as long as the script is the same <code>RunContext</code> as the script that created the emitter.</li> <li>Example: <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal VortexFXParticles = require(ReplicatedStorage:WaitForChild(\"VortexFXParticles\"))\nlocal emitter = VortexFXParticles:GetEmitterFromID(\"EmitterID1\") -- Emitter will be set to whatever emitter already exists and is paired with \"EmitterID1\"\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#flipbook","title":"Flipbook","text":"<ul> <li>Description: Enables particles to cycle through multiple meshes and textures during their lifetime, creating an animated flipbook effect. The mesh and texture IDs are updated at a specified frame rate, and the animation can follow different patterns.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({\n    Flipbook = { -- Define the frames for the flipbook animation\n        {\n            MeshId = 'rbxassetid://1',\n            TextureId = 'rbxassetid://2'\n        },\n        {\n            MeshId = 'rbxassetid://3',\n            TextureId = 'rbxassetid://4'\n        },\n        {\n            MeshId = 'rbxassetid://5',\n            TextureId = 'rbxassetid://6'\n        },\n        {\n            MeshId = 'rbxassetid://7',\n            TextureId = 'rbxassetid://8'\n        }\n    },\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#flipbookmode","title":"FlipbookMode","text":"<ul> <li>Description: Determines the cycling pattern of the flipbook frames. Available modes are:</li> <li>Loop: Cycles through all frames from start to end, then loops back to the first frame.</li> <li>OneShot: Runs through all frames once, starting from the first frame, and adjusts frame rate to match the particle's lifetime.</li> <li>PingPong: Moves through the frames forward to the last frame, then reverses back to the first frame at the same frame rate.</li> <li>Random: Selects a random frame at each interval.</li> <li>Default: <code>Enum.ParticleFlipbookMode.OneShot</code></li> </ul>"},{"location":"properties/advanced-properties/#flipbookframerate","title":"FlipbookFrameRate","text":"<p>OneShot Ignores FrameRate</p> <p>When using <code>OneShot</code> as a <code>FlipbookMode</code>, the frame rate is ignored as <code>OneShot</code> adjusts the frame rate to match the particles lifetime.</p> <ul> <li>Description: Sets the frame rate for the flipbook animation. Can be a fixed number or a <code>NumberRange</code> to randomize the rate.</li> <li>Default: <code>2</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will cycle through frames at a random frame rate between 1 and 4 frames per second\n    Flipbook = {}\n    FlipbookFrameRate = NumberRange.new(1, 4)\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#flipbookstartrandom","title":"FlipbookStartRandom","text":"<ul> <li>Description: If enabled, the flipbook animation starts at a random frame instead of the first frame.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles start at a random frame in the flipbook\n    Flipbook = {}\n    FlipbookStartRandom = true\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#velocityinheritance","title":"VelocityInheritance","text":"<ul> <li>Description: Controls how much of the adornee's velocity is inherited by emitted particles. This allows particles to carry over the momentum of the object they are emitted from.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({\n    VelocityInheritance = 0.5 -- Particles inherit 50% of the adornee's velocity\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#velocityinheritor","title":"VelocityInheritor","text":"<ul> <li>Description: What instance the particles take velocity from, singular instances only.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({\n    VelocityInheritor = game.Workspace.VelocityCauser -- Particles inherit the velocity from this object\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#keeporiginaltransparencies","title":"KeepOriginalTransparencies","text":"<ul> <li>Description: Determines if all transparency related parts inside a model being emitted remains how it was when the model is first added.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    KeepOriginalTransparencies = true -- Original transparencies are kept from the original model\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#keeporiginalcolors","title":"KeepOriginalColors","text":"<ul> <li>Description: Determines if all colors given to parts inside a model being emitted remains how it was when the model is first added.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    KeepOriginalColors = true -- Original colors are kept from the original model\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#keeporiginalmaterials","title":"KeepOriginalMaterials","text":"<ul> <li>Description: Determines if all materials on parts inside a model being emitted remains how it was when the model is first added.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    KeepOriginalMaterials = true -- Original materials are kept from the original model\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#attractor","title":"Attractor","text":"<ul> <li>Description: A Table of or a single instance that pulls particles in, think of the attractor as the positive side of a magnet and the particles metal fragments.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({\n    Attractor = game.Workspace.Attractor -- This object will pull particles in\n})\n</code></pre>   OR   <pre><code>emitter:Create({\n    Attractor = {game.Workspace.Attractor1, game.Workspace.Attractor2, game.Workspace.Attractor3} -- These objects will pull particles in\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#repulsor","title":"Repulsor","text":"<ul> <li>Description: A Table of or a single instance that pushes particles away, think of the repulsor as the positive side of a magnet and the particles another positive sided magnet.</li> <li>Default: <code>nil</code></li> <li>Example:    ```lua   emitter:Create({       Repulsor = game.Workspace.Repulsor -- This object will push particles away   })   <pre><code>OR\n```lua\nemitter:Create({\n    Repulsor = {game.Workspace.Repulsor1, game.Workspace.Repulsor2, game.Workspace.Repulsor3} -- These objects will push particles away\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#attractorrange","title":"AttractorRange","text":"<ul> <li>Description: The range at which the attractor starts pulling particles.</li> <li>Default: <code>40</code></li> <li>Example: <pre><code>emitter:Create({\n    AttractorRange = 100 -- A particle will start being effected when the attractor is within 100 studs of a particle\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#attractorstyle","title":"AttractorStyle","text":"<ul> <li>Description: The graph style of the attractor.</li> <li>Default: <code>Enum.EasingStyle.Linear</code></li> <li>Example: <pre><code>emitter:Create({\n    AttractorStyle = Enum.EasingStyle.Exponential -- The attractor will have an exponential amount of pull on the particles, close = a lot of pull, far = very little pull\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#attractorintensity","title":"AttractorIntensity","text":"<ul> <li>Description: How intense the pull that particles go under, higher = more pull, lower = less pull.</li> <li>Default: <code>10</code></li> <li>Example: <pre><code>emitter:Create({\n    AttractorIntensity = 25 -- The particles will be pulled enough to look like a normal magnet\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#repulsorrange","title":"RepulsorRange","text":"<ul> <li>Description: The range at which the repulsor starts pushing particles.</li> <li>Default: <code>40</code></li> <li>Example: <pre><code>emitter:Create({\n    RepulsorRange = 100 -- A particle will start being effected when the repulsor is within 100 studs of a particle\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#repulsorstyle","title":"RepulsorStyle","text":"<ul> <li>Description: The graph style of the repulsor.</li> <li>Default: <code>Enum.EasingStyle.Linear</code></li> <li>Example: <pre><code>emitter:Create({\n    RepulsorStyle = Enum.EasingStyle.Exponential -- The attractor will have an exponential amount of push on the particles, close = a lot of push, far = very little push\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#repulsorintensity","title":"RepulsorIntensity","text":"<ul> <li>Description: How intense the push that particles go under, higher = more push, lower = less push.</li> <li>Default: <code>10</code></li> <li>Example: <pre><code>emitter:Create({\n    RepulsorIntensity = 50 -- The particles will be pulled enough to look like 2 magnets facing eachother\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#collisiongroup","title":"CollisionGroup","text":"<ul> <li>Description: The collision group of particles.</li> <li>Default: <code>\"Default\"</code></li> <li>Example: <pre><code>emitter:Create({\n    CollisionGroup = \"Particles\"  -- Particles will only collide with objects the collision group \"Particles\" will have set to collision.\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#particleemitter2d-deprecated","title":"ParticleEmitter2D (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: When specified, each particle emits their own 2D particle emitter.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will emit particles cloned from a ParticleEmitter\n    ParticleEmitter2D = game.Workspace:FindFirstChild(\"ParticleEmitter\")\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#isshapemesh-deprecated","title":"IsShapeMesh (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: When enabled, the part will emit <code>Mesh</code> objects instead of regular <code>Part</code> objects</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will emit as MeshParts instead of Parts\n    IsShapeMesh = true\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#meshid-deprecated","title":"MeshID (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: When specified, the <code>Mesh</code> object will use this <code>MeshID</code></li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will have the MeshId of 0\n    IsShapeMesh = true,\n    MeshId = rbxassetid://0\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#trail-deprecated","title":"Trail (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: When specified, the <code>Mesh</code> object will have a <code>Trail</code></li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will have a trail instance\n    Trail = game.Workspace:FindFirstChild(\"Trail\")\n})\n</code></pre></li> </ul>"},{"location":"properties/advanced-properties/#textureid-deprecated","title":"TextureID (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: When specified, the <code>Mesh</code> object will use this <code>TextureID</code></li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will have the TextureId of 0\n    IsShapeMesh = true,\n    TextureId = rbxassetid://0\n})\n</code></pre></li> </ul> <p>These advanced properties give you even more control and customization for your particle.</p>"},{"location":"properties/audio/","title":"Audio Properties","text":"<p>The system can be customized to react to audio, letting you to create effects that sync with music or other sounds in your game. VortexFX is quite powerful when it comes to audio, as it has many features that can be easily accessed and to nearly every time provide a good result.</p> <p>Note</p> <p>All audio properties must have an <code>AudioReactive</code> property paired together or else it simply won't do anything.</p>"},{"location":"properties/audio/#audioreactive","title":"AudioReactive","text":"<ul> <li>Description: Links a sound object to the particle system, making the particles react to the sound's playback.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>local sound = workspace:WaitForChild(\"Sound\") -- Replace with a sound instance\nemitter:Create({ -- Particles will react to this sound but not without any of the influences below\n    AudioReactive = sound \n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audioinfluencedcolor","title":"AudioInfluencedColor","text":"<p>Saturation notice</p> <p><code>AudioInfluencedColor</code> changes the HUE of the color the particle is at spawn, if your particle has no saturation in any color, there will be no visible change.</p> <p>Compatibility</p> <p><code>AudioInfluencedColor</code> is NOT compatible with <code>ColorSequence</code>, if your particle has a <code>ColorSequence</code> applied, the color will be set to the first keypoint and it will not go through the <code>ColorSequence</code> as expected.</p> <ul> <li>Description: Allows the color of the particles to change based on the loudness of the linked audio.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles change color based on audio loudness\n    AudioReactive = sound,\n    AudioInfluencedColor = true\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audioinfluencedspeed","title":"AudioInfluencedSpeed","text":"<ul> <li>Description: Makes the speed of the particles fluctuate according to the loudness of the audio.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particle speed varies with audio loudness\n    AudioReactive = sound,\n    AudioInfluencedSpeed = true\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audioinfluencedsize","title":"AudioInfluencedSize","text":"<ul> <li>Description: Alters the size of the particles in sync with the audio's loudness.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particle size changes with audio loudness\n    AudioReactive = sound,\n    AudioInfluencedSize = true\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audioindependentspeed","title":"AudioIndependentSpeed","text":"<ul> <li>Description: When set to true, this property makes it that the particle's speed remains constant and isn't affected by audio changes past when it was first created, even if <code>AudioInfluencedSpeed</code> is enabled.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    AudioReactive = sound, -- Particle speed remains constant despite audio fluctuations\n    AudioInfluencedSpeed = true,\n    AudioIndependentSpeed = true\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audioindependentsize","title":"AudioIndependentSize","text":"<ul> <li>Description: Similar to <code>AudioIndependentSpeed</code>, this keeps the particle size constant, unaffected by the audio changes past when the particle was first created, even if <code>AudioInfluencedSize</code> is enabled.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particle size remains constant despite audio fluctuations\n    AudioReactive = sound,\n    AudioInfluencedSize = true,\n    AudioIndependentSize = true\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audioindependentcolor","title":"AudioIndependentColor","text":"<ul> <li>Description: This property makes sure that the particle color does not change with audio changes past when the particle was first created, even if <code>AudioInfluencedColor</code> is enabled.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particle color remains constant despite audio fluctuations\n    AudioReactive = sound,\n    AudioInfluencedColor = true,\n    AudioIndependentColor = true\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audiomultiplierspeed","title":"AudioMultiplierSpeed","text":"<ul> <li>Description: Multiplies the audio's influence on particle speed. This allows you to scale how much the particle speed is affected by the audio, can be used with low <code>Speed</code> and high <code>AudioMultiplierSpeed</code> to increase the visible audio amount.</li> <li>Default: <code>1</code></li> <li>Example: <pre><code>emitter:Create({ -- Doubles the speed changes caused by audio loudness\n    AudioReactive = sound,\n    AudioInfluencedSpeed = true,\n    AudioMultiplierSpeed = 2\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audiomultipliersize","title":"AudioMultiplierSize","text":"<ul> <li>Description: Multiplies the audio's influence on particle size, scaling the effect the audio has on particle size.</li> <li>Default: <code>1</code></li> <li>Example: <pre><code>emitter:Create({ -- Lowers the size changes caused by audio loudness by half\n    AudioReactive = sound,\n    AudioInfluencedSize = true,\n    AudioMultiplierSize = 2\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#audiohueshift","title":"AudioHueShift","text":"<ul> <li>Description: Shifts the hue of the particle's color based on the audio's loudness, higher values are more colorful.</li> <li>Default: <code>0.15</code></li> <li>Example: <pre><code>emitter:Create({ -- Shifts the hue based on audio loudness\n    AudioReactive = sound,\n    AudioInfluencedColor = true,\n    HueShift = 1\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#beatdetectionthreshold","title":"BeatDetectionThreshold","text":"<ul> <li>Description: Controls how much the audio loudness should change between frames for the system to consider that point in music a beat or a hit.</li> <li>Default: <code>22.5</code></li> <li>Example: <pre><code>emitter:Create({ -- Audio loudness must increase by 25 within 2 frames to be considered a beat\n    AudioReactive = sound,\n    BeatDetectionThreshold = 25,\n})\n</code></pre></li> </ul>"},{"location":"properties/audio/#onbeat","title":"OnBeat","text":"<ul> <li>Description: A function that is played every beat or hit that the system detects, using <code>BeatDetectionThreshold</code> as it's source.</li> <li>Default: <code>0.15</code></li> <li>Example: <pre><code>emitter:Create({ -- Prints \"Beat\" everytime a beat happens\n    AudioReactive = sound,\n    OnBeat = function(particle)\n        print(\"Beat\")\n    end\n})\n</code></pre></li> </ul> <p>These audio properties let you to create particle effects that are in sync with your sounds.</p>"},{"location":"properties/basic-properties/","title":"Basic Properties","text":"<p>The system comes with many properties that you can adjust to create particle effects. Below are the basic properties that you can change.</p>"},{"location":"properties/basic-properties/#enabled","title":"Enabled","text":"<p>Recommendation</p> <p>While <code>emitter.enabled</code> works for starting and stopping the emitter, it is not recommended, and while <code>Enabled</code> is a property in the <code>emitter:Create({</code> that works, it also isn't recommended to use, it's more recommended to use <code>emitter:Start()</code> or <code>emitter:Stop()</code> immediately outside of the <code>emitter:Create({</code> table if you want to start the emitter disabled.</p> <ul> <li>Description: Control's whether the particles are emitting or not.</li> <li>Default: <code>true</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will emit\n    Enabled = true\n})\n</code></pre></li> </ul> <p>For starting and stopping an emitter outside of the <code>Create({</code> function, use:   <pre><code>local VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nlocal emitter = VortexFXParticles.new()\nemitter:Create({})\n\nemitter:Start()\nemitter:Stop()\nemitter:Kill()\n</code></pre></p>"},{"location":"properties/basic-properties/#acceleration","title":"Acceleration","text":"<ul> <li>Description: Controls the acceleration applied to particles, allowing them to speed up or slow down over time.</li> <li>Default: <code>Vector3.new(0, 0, 0)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will accelerate downward like gravity\n    Acceleration = Vector3.new(0, -10, 0)\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#color","title":"Color","text":"<ul> <li>Description: Sets the color of the particles. You can also use <code>ColorSequence</code> or <code>ColorSequenceKeypoint</code> to make particles change color over their lifetime.</li> <li>Default: <code>Color3.fromRGB(255, 255, 255)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles transition from red to yellow\n    Color = ColorSequence.new(Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 255, 0))\n})\n</code></pre> <pre><code>emitter:Create({ -- Particles transition from yellow to blue to green to red to white\n    Color = ColorSequence.new({\n      ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 235, 156)),\n      ColorSequenceKeypoint.new(0.25, Color3.fromRGB(110, 137, 255)),\n      ColorSequenceKeypoint.new(0.5, Color3.fromRGB(46, 255, 203)),\n      ColorSequenceKeypoint.new(0.75, Color3.fromRGB(255, 129, 131)),\n      ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255)),\n  })\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#drag","title":"Drag","text":"<ul> <li>Description: Applies drag to the particles, slowing them down over time.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will gradually slow down as they move\n    Drag = 0.5\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#emissiondirection","title":"EmissionDirection","text":"<ul> <li>Description: Control's which direction the particles emit from the emitter.</li> <li>Default: <code>Enum.NormalId.Top</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will emit right from the emitter\n    EmissionDirection = Enum.NormalId.Right\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#lifetime","title":"Lifetime","text":"<ul> <li>Description: Defines how long particles will live before disappearing. This can be set as a <code>NumberRange</code> for varied lifetimes or <code>Single</code> for determined lifetime.</li> <li>Default: <code>NumberRange.new(5, 10)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles live between 3 to 5 seconds\n    Lifetime = NumberRange.new(3, 5)\n})\n</code></pre> <pre><code>emitter:Create({ -- Particles live for 5 seconds\n    Lifetime = 5\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#shape","title":"Shape","text":"<ul> <li>Description: The shape of each particle when not using <code>ReferenceObject</code></li> <li>Default: <code>Enum.PartType.Block</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will emit as spheres\n    Shape = Enum.PartType.Ball\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#material","title":"Material","text":"<ul> <li>Description: The material of each particle when not using <code>ReferenceObject</code></li> <li>Default: <code>Enum.Material.SmoothPlastic</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will glow\n    Material = Enum.Material.Neon\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#rate","title":"Rate","text":"<p>High rate count</p> <p>It is not a good idea to go above 60 rate without a short lifetime or in bursts, as this can lag a client or the server, depending on what you run it on.</p> <ul> <li>Description: Determines how many particles are emitted per second.</li> <li>Default: <code>5</code></li> <li>Example: <pre><code>emitter:Create({ -- Emit 10 particles per second\n    Rate = 10\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#rotation","title":"Rotation","text":"<ul> <li>Description: Sets the initial rotation of the particles.</li> <li>Default: <code>Vector3.new(0, 0, 0)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles start with a 45 degree rotation on the Y-axis and Z-axis\n    Rotation = Vector3.new(0, 45, 45)\n})\n</code></pre> <pre><code>emitter:Create({ -- Particles randomize all axes fully\n    Rotation = {NumberRange.new(-360, 360), NumberRange.new(-360, 360), NumberRange.new(-360, 360)}\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#rotationspeed","title":"RotationSpeed","text":"<p>X axis warning</p> <p>The X axis in RotationSpeed is notorious for causing issues, I've researched far far into this and this is a problem with the way Roblox handles adding rotation, if possible, avoid high numbers of the X axis, this can only be fixed by Roblox, I can't fix this :/</p> <ul> <li>Description: Defines the speed at which particles rotate over their lifetime.</li> <li>Default: <code>Vector3.new(0, 0, 0)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles rotate at 10 degrees per second around the Y-axis\n    RotationSpeed = Vector3.new(0, 10, 0)\n})\n</code></pre> <pre><code>emitter:Create({ -- Particles rotate between -20 and 20 degrees per second around Y and Z axes\n    RotationSpeed = {0, NumberRange.new(-20, 20), NumberRange.new(-20, 20)}\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#size","title":"Size","text":"<ul> <li>Description: Sets the size of the particles. You can use <code>NumberSequence</code> or <code>NumberSequenceKeypoint</code> to make particles grow or shrink over time.</li> <li>Default: <code>NumberSequence.new(1)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles grow in size from 1 to 2 over their lifetime\n    Size = NumberSequence.new(1, 2)\n})\n</code></pre> <pre><code>emitter:Create({ -- Particles grow and shrink in size over their lifetime\n  Size = NumberSequence.new({\n      NumberSequenceKeypoint.new(0, 1.25),\n      NumberSequenceKeypoint.new(0.25, 0.4),\n      NumberSequenceKeypoint.new(0.5, 1.3),\n      NumberSequenceKeypoint.new(0.75, 2),\n      NumberSequenceKeypoint.new(1, 0),\n  })\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#speed","title":"Speed","text":"<ul> <li>Description: Controls the speed at which particles are emitted.</li> <li>Default: <code>NumberRange.new(5)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles emit with a random speed between 5 and 10\n    Speed = NumberRange.new(5, 10)\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#spreadangle","title":"SpreadAngle","text":"<ul> <li>Description: Determines the angle at which particles are emitted at X, Y, and Z values, giving you more directional control.</li> <li>Default: <code>Vector3.new(0, 0, 0)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles spread at angles between 15 and 30 degrees\n    SpreadAngle = Vector3.new(15, 30, 0)\n})\n</code></pre></li> </ul>"},{"location":"properties/basic-properties/#transparency","title":"Transparency","text":"<ul> <li>Description: Sets the transparency of the particles. You can use <code>NumberSequence</code> or <code>NumberSequenceKeypoint</code> to change transparency over time.</li> <li>Default: <code>NumberSequence.new(0)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles fade out over their whole lifetime\n    Transparency = NumberSequence.new(0, 1) \n})\n</code></pre> <pre><code>emitter:Create({ -- Particles flicker on and off over their whole lifetime\n  Transparency = NumberSequence.new({\n      NumberSequenceKeypoint.new(0, 0),\n      NumberSequenceKeypoint.new(0.25, 1),\n      NumberSequenceKeypoint.new(0.5, 0),\n      NumberSequenceKeypoint.new(0.75, 1),\n      NumberSequenceKeypoint.new(1, 0),\n  })\n})\n</code></pre></li> </ul> <p>These are the basic properties you can tweak to get started with VortexFX.</p>"},{"location":"properties/collision/","title":"Collision Properties","text":"<p>The system lets you to control how particles interact with the environment through collision. This part covers properties that manage how particles detect and respond to collisions, whether they bounce, stop, or pass through objects.</p> <p>Performance heavy</p> <p>Particles using smart collision use raycasting to determine when they hit something, this can be laggy, so it's not the best idea to use many particles with collision when going for compatibility on lower-end devices</p>"},{"location":"properties/collision/#cancollide","title":"CanCollide","text":"<ul> <li>Description: Controls if particles are collidable with physics objects, such as players</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Physics objects will collide with particles\n    CanCollide = true\n})\n</code></pre></li> </ul>"},{"location":"properties/collision/#enablecollision","title":"EnableCollision","text":"<ul> <li>Description: Enables collision detection for particles, allowing them to interact with objects in the world.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will collide with objects\n    EnableCollision = true\n})\n</code></pre></li> </ul>"},{"location":"properties/collision/#particlesaresolid","title":"ParticlesAreSolid","text":"<ul> <li>Description: When enabled, particles will treat itself on collision as a solid object, for example, a bouncy ball is a solid object, while fire is not. When this is false, the particles will spread out around the surface of the hit object, when this is true, the particles will bounce.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will bounce on collision\n    EnableCollision = true,\n    ParticlesAreSolid = true\n})\n</code></pre></li> </ul>"},{"location":"properties/collision/#collisionrange","title":"CollisionRange","text":"<ul> <li>Description: When provided, this number will be the range of raycasting around particles in studs.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will check for collision within 5 studs\n    EnableCollision = true,\n    CollisionRange = 5\n})\n</code></pre></li> </ul>"},{"location":"properties/collision/#oncollision","title":"OnCollision","text":"<ul> <li>Description: Lets you to use a function that is called whenever a particle collides with an object. This can be used to trigger specific effects, such as particles changing color's on impact or creating explosive rockets/objects.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will destroy themselves on collision\n    EnableCollision = true,\n    OnCollision = function(particle, velocity)\n      print(\"Hit with \" .. velocity.Magnitude)\n    end\n})\n</code></pre></li> </ul> <p>idk what to put here</p>"},{"location":"properties/debug-properties/","title":"Debug Properties","text":"<p>The system is always open to you or others modifying and changing how the system works and behaves, but good ways to do that is to have the ability to debug stuff.</p>"},{"location":"properties/debug-properties/#visualizeraycasts","title":"VisualizeRaycasts","text":"<ul> <li>Description: Changes whether or not raycasting is visualized and can be seen</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Show raycasts\n  VisualizeRaycasts = true\n})\n</code></pre></li> </ul> <p>With debugging, you can change the system yourself easier... were you expecting more??</p>"},{"location":"properties/event-functions/","title":"Functions","text":"<p>The system lets you call custom functions for your needs, whether it be when the particle spawns, is destroyed, reaches half it's lifetime, every frame, or when the particle collides with something paired with <code>EnableCollision</code></p>"},{"location":"properties/event-functions/#onspawn","title":"OnSpawn","text":"<ul> <li>Description: This function is called when a particle is first created or spawned.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Print \"particle spawned\" when called\n  OnSpawn = function(particle)\n      print(\"particle spawned\")\n  end\n})\n</code></pre></li> </ul>"},{"location":"properties/event-functions/#halflife","title":"HalfLife","text":"<ul> <li>Description: This function is called when a particle reaches half of its lifetime. Not affiliated with Half Life</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Print \"particle is at half life\" when called\n  HalfLife = function(particle)\n      print(\"particle is at half life\")\n  end\n})\n</code></pre></li> </ul>"},{"location":"properties/event-functions/#ondeath","title":"OnDeath","text":"<ul> <li>Description: This function is called when a particle is about to be destroyed or removed.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Print the particle name and \"has been destroyed\" when called\n  OnDeath = function(particle)\n      print(particle.Name .. \" has been destroyed\")\n  end\n})\n</code></pre></li> </ul>"},{"location":"properties/event-functions/#constantfunction","title":"ConstantFunction","text":"<ul> <li>Description: This function is called every frame prior to the frame being rendered.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Print the particles position every frame\n  ConstantFunction = function(particle)\n      print(tostring(particle.Position))\n  end\n})\n</code></pre></li> </ul>"},{"location":"properties/event-functions/#oncollision","title":"OnCollision","text":"<ul> <li>Description: Lets you to use a function that is called whenever a particle collides with an object. This function is paired with the velocity that the particle has when the function is called.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({ -- Destroy the particle on collision if the particle is moving faster than 10 studs per second\n  EnableCollision = true,\n  OnCollision = function(particle, velocity)\n      if velocity.Magnitude &gt; 10 then\n          particle:Destroy()\n      end\n  end\n}) \n</code></pre></li> </ul>"},{"location":"properties/event-functions/#onbeat","title":"OnBeat","text":"<ul> <li>Description: A function that is played every beat or hit that the system detects, using <code>BeatDetectionThreshold</code> as it's source.</li> <li>Default: <code>0.15</code></li> <li>Example: <pre><code>emitter:Create({ -- Prints \"Beat\" everytime a beat happens\n    AudioReactive = sound,\n    OnBeat = function(particle)\n        print(\"Beat\")\n    end\n})\n</code></pre></li> </ul> <p>These functions provide hooks into different stages of a particle's lifecycle, giving you the flexibility to create sophisticated effects. By defining custom functions for spawning, mid-life, death, and collision, you can control exactly how your particles behave and interact with the environment.</p>"},{"location":"properties/groups/","title":"Group Properties","text":"<p>Groups can be used on properties to have multiple particles all work in unison, creating pretty effects.</p> <p>Note</p> <p>The <code>Grouped</code> property must be true in order for any group-related properties to take effect.</p>"},{"location":"properties/groups/#grouped","title":"Grouped","text":"<ul> <li>Description: Enables group behavior for the particle system. When set to <code>true</code>, particles will work in groups based on the defined group properties.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#groupamount","title":"GroupAmount","text":"<ul> <li>Description: Specifies the number of groups the particles should be divided into.</li> <li>Default: <code>1</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupAmount = 3\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#particlespergroup","title":"ParticlesPerGroup","text":"<ul> <li>Description: Determines the number of particles per group.</li> <li>Default: <code>10</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    ParticlesPerGroup = 15\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#groupbehavior","title":"GroupBehavior","text":"<ul> <li>Description: Defines how particles in a group behave relative to each other. Possible values are:</li> <li><code>Follow</code>: Particles follow the group's heart particle.</li> <li><code>Cluster</code>: Particles stay in close proximity to the heart particle.</li> <li><code>Walk</code>: Particles move randomly within a certain range around the heart.</li> <li><code>Avoid</code>: Particles move away from the heart if they get too close.</li> <li><code>OneToOne</code>: Each particle maintains a specific offset from the heart particle.</li> <li><code>Orbit</code>: Particles orbit around the heart particle.</li> <li>Default: <code>Follow</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Orbit\"\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#grouprotationbehavior","title":"GroupRotationBehavior","text":"<ul> <li>Description: Specifies how particle rotations are influenced by the heart particle.</li> <li><code>Clone</code>: All particles copy the rotation of the heart particle.</li> <li><code>Independent</code>: Particles maintain their individual rotations.</li> <li>Default: <code>Clone</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupRotationBehavior = \"Independent\"\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#groupbehavioronheartdeath","title":"GroupBehaviorOnHeartDeath","text":"<ul> <li>Description: Determines what happens to the group if the heart particle dies.</li> <li><code>Scatter</code>: Particles scatter in random directions.</li> <li><code>Continue</code>: Particles continue with the current behavior.</li> <li><code>Reassign</code>: A new heart particle is chosen from the group.</li> <li><code>Kill</code>: All particles in the group are killed.</li> <li>Default: <code>Scatter</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehaviorOnHeartDeath = \"Reassign\"\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#scatterpower","title":"ScatterPower","text":"<ul> <li>Description: The power with which particles scatter when the heart particle dies.</li> <li>Default: <code>10</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehaviorOnHeartDeath = \"Scatter\",\n    ScatterPower = 15\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#avoiddistance","title":"AvoidDistance","text":"<ul> <li>Description: Specifies the distance at which particles will start avoiding the heart particle when <code>GroupBehavior</code> is set to <code>Avoid</code>.</li> <li>Default: <code>5</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Avoid\",\n    AvoidDistance = 10\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#clusterdistance","title":"ClusterDistance","text":"<ul> <li>Description: Specifies the maximum distance that particles can be from the heart particle when <code>GroupBehavior</code> is set to <code>Cluster</code>.</li> <li>Default: <code>2</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Cluster\",\n    ClusterDistance = 3\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#groupwalkextents","title":"GroupWalkExtents","text":"<ul> <li>Description: Defines the 3D space within which particles can move when <code>GroupBehavior</code> is set to <code>Walk</code>.</li> <li>Default: <code>Vector3.new(5, 5, 5)</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Walk\",\n    GroupWalkExtents = Vector3.new(10, 10, 10)\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#groupwalkaggression","title":"GroupWalkAggression","text":"<ul> <li>Description: Determines how aggressively particles move within the defined walk extents.</li> <li>Default: <code>0.5</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Walk\",\n    GroupWalkAggression = 1\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#onetooneoffset","title":"OneToOneOffset","text":"<ul> <li>Description: Defines the offset that each particle maintains from the heart particle when <code>GroupBehavior</code> is set to <code>OneToOne</code>.</li> <li>Default: <code>Vector3.new(0, 0, 0)</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"OneToOne\",\n    OneToOneOffset = Vector3.new(1, 1, 1)\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#groupkilldelay","title":"GroupKillDelay","text":"<ul> <li>Description: Specifies the delay before all particles in a group are killed after the heart particle dies, when <code>GroupBehaviorOnHeartDeath</code> is set to <code>Kill</code>.</li> <li>Default: <code>nil</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehaviorOnHeartDeath = \"Kill\",\n    GroupKillDelay = 0.5\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#grouporbitrange","title":"GroupOrbitRange","text":"<ul> <li>Description: Specifies the radius of the orbit when <code>GroupBehavior</code> is set to <code>Orbit</code>.</li> <li>Default: <code>10</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Orbit\",\n    GroupOrbitRange = 15\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#grouporbitaxis","title":"GroupOrbitAxis","text":"<ul> <li>Description: Defines the axis around which particles orbit when <code>GroupBehavior</code> is set to <code>Orbit</code>.</li> <li>Default: <code>Vector3.new(0, 1, 0)</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Orbit\",\n    GroupOrbitAxis = Vector3.new(1, 0, 0)\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#grouporbitspeed","title":"GroupOrbitSpeed","text":"<ul> <li>Description: Specifies the speed at which particles orbit around the heart particle when <code>GroupBehavior</code> is set to <code>Orbit</code>.</li> <li>Default: <code>1</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Orbit\",\n    GroupOrbitSpeed = 2\n})\n</code></pre></li> </ul>"},{"location":"properties/groups/#grouporbitsmoothing","title":"GroupOrbitSmoothing","text":"<ul> <li>Description: Controls the smoothing of the orbit movement, making the orbit more or less fluid.</li> <li>Default: <code>1</code></li> <li>Example: <pre><code>emitter:Create({\n    Grouped = true,\n    GroupBehavior = \"Orbit\",\n    GroupOrbitSmoothing = 0.8\n})\n</code></pre></li> </ul> <p>These group particles further increase just what you can do with this system combined with other properties by a lot.</p>"},{"location":"properties/instability/","title":"Instability Properties","text":"<p>The system comes with a property list that can allow you to create randomness involving positions.</p>"},{"location":"properties/instability/#instability","title":"Instability","text":"<ul> <li>Description: Introduces a base level of randomness to the position of particles. This technically is more Intensity than a base level, it is the amount the particle will move in 3D space in studs</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will jitter slightly\n    Instability = 2\n})\n</code></pre></li> </ul>"},{"location":"properties/instability/#instabilityintensity","title":"InstabilityIntensity","text":"<ul> <li>Description: Controls the intensity of the <code>Instability</code> effect. This belongs more to a <code>Instability</code> rate more than intensity, as this value will be how many times the <code>Instability</code> jitter will happen per second</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will have intense fast-paced movement\n    Instability = 2,\n    InstabilityIntensity = 12\n})\n</code></pre></li> </ul>"},{"location":"properties/instability/#instabilitysmoothness","title":"InstabilitySmoothness","text":"<ul> <li>Description: Controls the percentage of how fast <code>Instability</code> happens on a percentage scale of 0 to 100 (which can go past 100%). 0% is so slow instability doesnt seem to work, 100% is semi-instant.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Instability will be smooth but still have visible changes.\n    Instability = 2,\n    InstabilitySmoothness = 50\n})\n</code></pre></li> </ul> <p><code>Instability</code> properties allow you to mimic electricity effects or randomness or paired with the smoothness can be created to mimic flies or flying animals. <code>Instability</code> is a useful property when used right.</p>"},{"location":"properties/light/","title":"Light Properties","text":"<p>The system allows you to control how particles interact with light in your game environment. This has influencing particles with light sources and managing how particles emit light themselves.</p> <p>Light Influence Properties are still in development</p> <p>You may experience flickering, shadow casting issues, or other visual problems when using light properties. If these happen, maybeee consider turning off shadows or reducing the number of active lights to minimize the impact. Most of the flickering and issues happen with shadows in general.</p>"},{"location":"properties/light/#lightinfluenceenabled","title":"LightInfluenceEnabled","text":"<ul> <li>Description: Enables the particles to be influenced by the surrounding light sources. When activated, particles can change color and brightness based on the lights in the environment.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will react to nearby light sources\n    LightInfluenceEnabled = true\n})\n</code></pre></li> </ul>"},{"location":"properties/light/#lightbrightnessinfluence","title":"LightBrightnessInfluence","text":"<ul> <li>Description: Controls how much the brightness of the light sources affects the particles. A higher value increases the influence of light brightness on the particles.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles are fully influenced by light brightness\n    LightInfluenceEnabled = true,\n    LightBrightnessInfluence = 1\n})\n</code></pre></li> </ul>"},{"location":"properties/light/#lightinfluencesensitivity","title":"LightInfluenceSensitivity","text":"<ul> <li>Description: Adjusts the sensitivity of the particles to changes in light. Higher values make particles more reactive to light intensity changes.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles are highly sensitive to changes in light\n    LightInfluenceEnabled = true,\n    LightInfluenceSensitivity = 3\n})\n</code></pre></li> </ul>"},{"location":"properties/light/#lightcolorinfluence","title":"LightColorInfluence","text":"<ul> <li>Description: Determines how much the color of the light sources affects the particle color. A higher value means the particle color will change more dramatically based on the surrounding lights.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles' color is fully influenced by light colors\n    LightInfluenceEnabled = true,\n    LightColorInfluence = 1\n})\n</code></pre></li> </ul>"},{"location":"properties/light/#lightemission","title":"LightEmission","text":"<p>Deprecated, cause its literally just useless lol, just apply different colors onto your particle itself.</p> <ul> <li>Description: Sets the brightness of light emitted by the particles themselves. Useful for creating glowing or light-emitting particles. Higher values add more \"white\" into the color, lower values saturate the color more, recommended to stay between 0 and 1.</li> <li>Default: <code>0</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles are bright\n    EmitLight = true,\n    LightEmission = 0.75\n})\n</code></pre></li> </ul>"},{"location":"properties/light/#emitlight-deprecated","title":"EmitLight (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: Previously used to make particles emit light. It is now recommended to use the <code>ManualLightProperties</code> property for more control and future compatibility.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    EmitLight = true\n})\n</code></pre></li> </ul>"},{"location":"properties/light/#manuallightproperties-deprecated","title":"ManualLightProperties (Deprecated)","text":"<p>Deprecated, use <code>ReferenceObject</code></p> <ul> <li>Description: When enabled, allows you to manually adjust properties of the light emitted by the particles, such as brightness, color, and range.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({\n    EmitLight = true,\n    ManualLightProperties = true,\n    LightBrightness = 10,\n    LightColor = Color3.fromRGB(255, 255, 255),\n    LightRange = 15,\n    LightShadows = true\n})\n</code></pre></li> </ul> <p>These light properties give you control over how particles interact with light in your game world, adding another layer of visual appeal.</p>"},{"location":"properties/particle-commands/","title":"Particle Commands","text":"<p>The system allows you to change and modify particles directly using a list of given commands and functions</p>"},{"location":"properties/particle-commands/#start","title":"Start","text":"<ul> <li>Description: Will start the emitter</li> <li>Example: <pre><code>local VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nlocal emitter = VortexFXParticles.new()\nemitter:Create({})\n\nemitter:Start()\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#stop","title":"Stop","text":"<ul> <li>Description: Will stop the emitter from emitting particles</li> <li>Example: <pre><code>local VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nlocal emitter = VortexFXParticles.new()\nemitter:Create({})\n\nemitter:Stop()\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#kill","title":"Kill","text":"<ul> <li>Description: Will stop the emitter from emitting particles and remove all particles that are active and from that emitter</li> <li>Example: <pre><code>local VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nlocal emitter = VortexFXParticles.new()\nemitter:Create({})\n\nemitter:Kill()\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#freezeparticle","title":"FreezeParticle","text":"<ul> <li>Description: The function can be called on a certain particle object to freeze it in place, transparency, colors, and other properties will still take effect.</li> <li>Example: <pre><code>-- Will feeeze a particle, stopping its velocity and rotation to where it last was\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:FreezeParticle(particle)\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#unfreezeparticle","title":"UnfreezeParticle","text":"<ul> <li>Description: The function can be called on a certain particle object to resume it's frozen state, resuming position and rotation, not inherting velocity from when it was last active.</li> <li>Example: <pre><code>-- Will unfreeze a particle, resuming its velocity and rotation\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:UnfreezeParticle(particle)\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#getactiveparticlescount","title":"GetActiveParticlesCount","text":"<ul> <li>Description: The function can be called to get the amount of particles that are active and being updated.</li> <li>Example: <pre><code>-- Will return the amount of particles currently active in the entire world\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nlocal particleCount = VortexFXParticles:GetActiveParticlesCount()\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#changeparticleproperty","title":"ChangeParticleProperty","text":"<ul> <li>Description: The function can be called on a certain particle object to change any of it's properties that exist on that particle alone, this excludes EnableCollision, AudioReactive, and other properties as they are not independent to particles, properties like Size or Transparency will work.</li> <li>Example: <pre><code>-- Will change the particles size to 5\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:ChangeParticleProperty(particle, Size, 5)\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#destroyparticle","title":"DestroyParticle","text":"<ul> <li>Description: The function can be called to destroy a certain particle.</li> <li>Example: <pre><code>local VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:DestroyParticle(particle)\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#setparticleposition","title":"SetParticlePosition","text":"<ul> <li>Description: The function can be called to instantly set the position of any particle object to a <code>Vector3</code>.</li> <li>Example: <pre><code>-- Will set the position of the particle to 0, 10, 0\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:SetParticlePosition(particle, Vector3.new(0, 10, 0))\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#setparticleorientation","title":"SetParticleOrientation","text":"<ul> <li>Description: The function can be called to instantly set the orientation of any particle object to a <code>Vector3</code>.</li> <li>Example: <pre><code>-- Will set the rotation/orientation of a particle to 45 degrees on the X and Z axis\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:SetParticleOrientation(particle, Vector3.new(45, 0, 45))\n</code></pre></li> </ul>"},{"location":"properties/particle-commands/#resetrotation","title":"ResetRotation","text":"<ul> <li>Description: The function can be called to reset specific or multiple axes of a particle's rotation, followed with an option to smoothly fade in a particle's rotation.</li> <li>Example: <pre><code>-- Will reset the X, and Z rotation with a smooth fade in.\nlocal VortexFXParticles = require(game:GetService(\"ReplicatedStorage\").VortexFXParticles)\nVortexFXParticles:ResetRotation(particle, true, false, true, true)\n</code></pre></li> </ul> <p>These commands give you much more control over what you can do with particles, keep in mind it requires a particles PART, or the objects inside of workspace &gt; VortexFXCache while the game is running.</p>"},{"location":"properties/performance-properties/","title":"Particle Commands","text":"<p>The system's main goal is to provide 3D particles at the best performance and optimization as possible, these properties can help reduce lag depending on what you choose.</p> <p>Client side only</p> <p>All of the performance methods that involve culling or cameras are client sided only and can only be used on emitters that have been created on the client.</p>"},{"location":"properties/performance-properties/#cullingenabled","title":"CullingEnabled","text":"<ul> <li>Description: Will stop emitting particles when the player's camera looks away from the emitter.</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will stop emitting when a player looks away.\n    CullingEnabled = true\n})\n</code></pre></li> </ul>"},{"location":"properties/performance-properties/#aggressivecullingenabled","title":"AggressiveCullingEnabled","text":"<ul> <li>Description: Will stop updating all particles when a player's camera looks away from the emitter, this is a better choice than <code>CullingEnabled</code> if you want the particles to start faster, but <code>CullingEnabled</code> is superior if you want the most amount of performance. Most performance properties are compatible with <code>AggressiveCullingEnabled</code></li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will stop updating when a player looks away.\n    AggressiveCullingEnabled = true\n})\n</code></pre></li> </ul>"},{"location":"properties/performance-properties/#focusaware","title":"FocusAware","text":"<ul> <li>Description: Will stop emitting particles when the player minimizes the Roblox client or focuses on a different application</li> <li>Default: <code>false</code></li> <li> <p>Example: <pre><code>emitter:Create({ -- Particles will stop emitting when a player focuses on a different application\n    FocusAware = true\n})\n</code></pre></p> </li> <li> <p>Example 2: <pre><code>emitter:Create({ -- Particles will stop updating when a player focuses on a different application\n    AggressiveCullingEnabled = true,\n    FocusAware = true\n})\n</code></pre></p> </li> </ul>"},{"location":"properties/performance-properties/#renderdistance","title":"RenderDistance","text":"<ul> <li>Description: Will stop emitting particles when the players camera is the distance specified from the emitter</li> <li>Default: <code>514</code></li> <li> <p>Example: <pre><code>emitter:Create({ -- Particles will stop emitting when a players camera is 200 studs away from the emitter\n    RenderDistance = 200\n})\n</code></pre></p> </li> <li> <p>Example 2: <pre><code>emitter:Create({ -- Particles will lower the maximum particles that can exist from this emitter the further the players camera is from the emitter\n    RenderDistance = 200,\n    MaximumParticleCount = 100,\n    AdaptiveParticleLimits = true\n})\n</code></pre></p> </li> </ul>"},{"location":"properties/performance-properties/#maximumparticlecount-minimumparticlecount","title":"MaximumParticleCount &amp; MinimumParticleCount","text":"<ul> <li>Description: The maximum and minimum amount of particles that can be emitted from an emitter at once, used especially in twine with <code>RenderDistance</code> and <code>AdaptiveParticleLimits</code></li> <li>Default: <code>240 &amp; 5</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will stop emitting when a player looks away.\n    MaximumParticleCount = 100\n    MinimumParticleCount = 5\n})\n</code></pre></li> </ul>"},{"location":"properties/performance-properties/#adaptiveparticlelimits","title":"AdaptiveParticleLimits","text":"<ul> <li>Description: Will lower the maximum amount of particles that can exist from an emitter the further the players camera is from the emitter</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will lower the maximum particles that can exist from this emitter the further the players camera is from the emitter\n    RenderDistance = 200,\n    MaximumParticleCount = 100,\n    AdaptiveParticleLimits = true\n})\n</code></pre></li> </ul>"},{"location":"properties/performance-properties/#cullingextentsoffset","title":"CullingExtentsOffset","text":"<ul> <li>Description: Will determine the distance the camera needs to look towards the emitter to disable or enable the emitter.</li> <li>Default: <code>Vector3.new(0, 0, 0)</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will stop emitting when a player looks away within 5 studs of the emitter\n    CullingExtentsOffset = Vector3.new(5, 5, 5)\n})\n</code></pre></li> </ul> <p>These properties allow you to use more particles with minimal performance reduction.</p>"},{"location":"properties/trajectory/","title":"Trajectory Properties","text":"<p>The system has properties that allow you to create specific paths for particles to follow. These trajectory properties let you to have effects where particles move along routes, making shapes or traveling through set points in space.</p>"},{"location":"properties/trajectory/#trajectorialvertices","title":"TrajectorialVertices","text":"<ul> <li>Description: When this table has at least 1 <code>Vector3</code> inside the table, the particles will attempt to move to the position of the <code>Vector3</code>, when there are multiple <code>Vector3</code>'s in the table, the particles will move from the first, to the second, then back to the first, it will loop.</li> <li>Default: <code>{}</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will follow these points in space\n    TrajectorialVertices = {\n        Vector3.new(0, 0, 0),\n        Vector3.new(10, 0, 0),\n        Vector3.new(10, 10, 0),\n        Vector3.new(0, 10, 0)\n    }\n})\n</code></pre></li> </ul>"},{"location":"properties/trajectory/#trajectorialsmoothening","title":"TrajectorialSmoothening","text":"<ul> <li>Description: Controls how smooth the particles take corners around the <code>Vector3</code>'s used in <code>TrajectorialVertices</code>, higher values will be more aggressive and snappy around corners, smaller values will be more soft and flowy around corners.</li> <li>Default: <code>0.1</code></li> <li>Example: <pre><code>emitter:Create({ -- Particles will be slightly smooth around corners\n    TrajectorialVertices = {\n        Vector3.new(0, 0, 0),\n        Vector3.new(5, 5, 5),\n        Vector3.new(10, 0, 0)\n    },\n    TrajectorialSmoothening = 0.25\n})\n</code></pre></li> </ul> <p>Using trajectorial vertices, you can make particles follow a set path, this can be used for lightning paired with <code>Instability</code> or shapes.</p>"}]}